{
    "common": {
        "label": {
            "payload": "Payload",
            "topic": "Topic",
            "name": "Nom",
            "username": "Nom d'utilisateur",
            "password": "Mot de passe"
        },
        "status": {
            "connected": "connecté",
            "not-connected": "non connecté",
            "disconnected": "déconnecté",
            "connecting": "connexion...",
            "error": "erreur",
            "ok": "OK"
        },
        "notification": {
            "error": "<strong>Erreur</strong>: __message__",
            "errors": {
                "not-deployed": "nœud non-déployé",
                "no-response": "pas de réponse du serveur",
                "unexpected": "erreur inattendue (__status__) __message__"
            }
        },
        "errors": {
            "nooverride": "Alerte: les propriétés de msg ne peuvent plus surcharger les propriétés inscrites. Voir bit.ly/nr-override-msg-props"
        }
    },
    "inject": {
        "inject": "injecter",
        "repeat": "répétition = __repeat__",
        "crontab": "crontab = __crontab__",
        "stopped": "arrêté",
        "failed": "Injection échouée: __error__",
        "label": {
            "repeat": "Répétition"
        },
        "timestamp": "horodatage",
        "none": "aucune",
        "interval": "intervalle",
        "interval-time": "intervalle sporadique",
        "time": "à un moment précis",
        "seconds": "secondes",
        "minutes": "minutes",
        "hours": "heures",
        "between": "entre",
        "previous": "valeur précédente",
        "at": "à",
        "and": "et",
        "every": "toute les",
        "days": [
            "Lundi",
            "Mardi",
            "Mercredi",
            "Jeudi",
            "Vendredi",
            "Samedi",
            "Dimanche"
        ],
        "on": "le",
        "onstart": "Injecter une fois au départ ?",
        "tip": "<b>Note:</b> \"intervalle\" et \"à un moment précis\" utilise cron.<br/>Voir le panneau info pour plus de détails.",
        "success": "Injection réussie: __label__",
        "errors": {
            "failed": "injection échouée, voir le journal pour les détails"
        }
    },
    "catch": {
        "catch": "attraper tout",
        "catchNodes": "attraper (__number__)",
        "label": {
            "source": "Attraper les erreurs de",
            "node": "nœud",
            "type": "type",
            "selectAll": "tout sélectionner",
            "sortByLabel": "trier par étiquette",
            "sortByType": "trier par type"
        },
        "scope": {
            "all": "tous les nœuds",
            "selected": "nœuds sélectionnés"
        }
    },
    "status": {
        "status": "statut (tous)",
        "statusNodes": "statut (__number__)",
        "label": {
            "source": "Obtenir le statut de",
            "node": "nœud",
            "type": "type",
            "selectAll": "tout sélectionner",
            "sortByLabel": "trier par étiquette",
            "sortByType": "trier par type"
        },
        "scope": {
            "all": "tous les nœuds",
            "selected": "nœuds sélectionnés"
        }
    },
    "debug": {
        "output": "Sortie",
        "msgprop": "propriété du message",
        "msgobj": "objet msg complet",
        "to": "vers",
        "debtab": "onglet débogage",
        "tabcon": "onglet débogage et console",
        "notification": {
            "activated": "Activation réussie: __label__",
            "deactivated": "Désactivation réussie: __label__"
        },
        "sidebar": {
            "label": "débogage",
            "name": "Messages de débogage",
            "filterAll": "tous les nœuds",
            "filterSelected": "nœuds sélectionnés",
            "filterCurrent": "flux courant",
            "debugNodes": "Nœuds de débogage",
            "clearLog": "effacer les messages",
            "openWindow": "ouvrir dans une nouvelle fenêtre"
        },
        "messageMenu": {
            "collapseAll": "Réduire tous les chemins",
            "clearPinned": "Retirer les ancres de chemins",
            "filterNode": "Filtrer ce nœud",
            "clearFilter": "Retirer le filtre"
        }
    },
    "link": {
        "linkIn": "lien entrant",
        "linkOut": "lien sortant",
        "label": {
            "event": "Nom d'événement",
            "node": "nom",
            "type": "flux",
            "sortByFlow":"Trié par flux",
            "sortByLabel": "Trié par nom"
        }
    },
    "tls": {
        "tls": "Configuration TLS",
        "label": {
            "use-local-files": "Utiliser la clef et les certificats à partir de fichiers locaux",
            "upload": "Téléverser",
            "cert": "Certificat",
            "key": "Clef privée",
            "ca": "Certificat CA",
            "verify-server-cert":"Vérifier le certificat du serveur"
        },
        "placeholder": {
            "cert":"Chemin vers le certificat (Format PEM)",
            "key":"Chemin vers la clef privée (Format PEM)",
            "ca":"Chemin vers le certificat CA (Format PEM)"
        },
        "error": {
            "missing-file": "Pas de certificat/clef fourni"
        }
    },
    "exec": {
        "label": {
            "command": "Commande",
            "append": "Ajouter",
            "timeout": "Délai d'attente",
            "timeoutplace": "optionnel",
            "return": "Sortie",
            "seconds": "secondes"
        },
        "placeholder": {
            "extraparams": "paramètres d'entrée supplémentaires"
        },
        "opt": {
            "exec": "quand la commande est complétée - mode exec",
            "spawn": "pendant que la commande s'éxécute- mode spawn"
        },
        "oldrc": "Utiliser l'ancien mode de sortie (mode compatible)"
    },
    "function": {
        "label": {
            "function": "Fonction",
            "outputs": "Sorties"
        },
        "error": {
            "inputListener":"Impossible d'ajouter un auditeur à l'énénement 'input' à l'intérieur d'une fonction",
            "non-message-returned":"La fonction a tenté d'envoyer un message de type __type__"
        },
        "tip": "Voir l'onglet Info pour de l'aide sur l'écriture de fonctions."
    },
    "template": {
        "label": {
            "template": "Modèle",
            "property": "Propriété",
            "format": "Coloration syntaxique",
            "syntax": "Format",
            "output": "Sortie",
            "mustache": "Modèle mustache",
            "plain": "Texte brut",
            "json": "JSON converti",
            "yaml": "YAML converti",
            "none": "aucun"
        },
        "templatevalue": "Ceci est le payload: {{payload}} !"
    },
    "delay": {
        "action": "Action",
        "for": "Pour",
        "delaymsg": "Délayer chaque message",
        "delayfixed": "Délai fixe",
        "delayvarmsg": "Utiliser msg.delay pour fixé le délai",
        "randomdelay": "Délai aléatoire",
        "limitrate": "Limiter le débit",
        "limitall": "Tous les message",
        "limittopic": "Pour chaque msg.topic",
        "fairqueue": "Envoyer chaque topic un à la suite de l'autre",
        "timedqueue": "Envoyer tous les topics",
        "milisecs": "Milisecondes",
        "secs": "Secondes",
        "sec": "Seconde",
        "mins": "Minutes",
        "min": "Minute",
        "hours": "Heures",
        "hour": "Heur",
        "days": "Jours",
        "day": "Jour",
        "between": "Entre",
        "and": "et",
        "rate": "Débit",
        "msgper": "msg(s) par",
        "dropmsg": "ignorer les messages intermédiaires",
        "label": {
            "delay": "délai",
            "variable": "variable",
            "limit": "limite",
            "limitTopic": "limite topic",
            "random": "aléatoire",
            "units" : {
                "second": {
                    "plural" : "Secondes",
                    "singular": "Seconde"
                },
                "minute": {
                    "plural" : "Minutes",
                    "singular": "Minute"
                },
                "hour": {
                    "plural" : "Heures",
                    "singular": "Heure"
                },
                "day": {
                    "plural" : "Jours",
                    "singular": "Jour"
                }
            }
        },
        "error": {
            "buffer": "le tampon a excédé 1000 messages",
            "buffer1": "le tampon a excédé 10000 messages"
        }
    },
    "trigger": {
        "send": "Envoyer",
        "then": "ensuite",
        "then-send": "et envoyer",
        "output": {
            "string": "la chaîne de caractères",
            "number": "le nombre",
            "existing": "l'objet msg existant",
            "original": "l'objet msg initial",
            "latest": "l'objet msg le plus récent",
            "nothing": "rien"
        },
        "wait-reset": "attendre d'être ré-initialisé",
        "wait-for": "attendre",
        "wait-loop": "ré-envoyer chaque",
        "duration": {
            "ms": "Millisecondse",
            "s": "Secondes",
            "m": "Minutes",
            "h": "Heures"
        },
        "extend": " prolonger le délai à l'arrivée d'un nouveau message",
        "label": {
            "trigger": "déclencher",
            "trigger-block": "déclencher et bloquer",
            "trigger-loop": "ré-envoyer chaque",
            "reset": "Ré-initialiser le déclencheur si:",
            "resetMessage":"msg.reset est assigné",
            "resetPayload":"msg.payload vaut",
            "resetprompt": "facultatif"
        }
    },
    "comment": {
        "label": {
            "title": "Titre",
            "body": "Corps"
        },
        "tip": "Conseil: Le corps du texte peut être stylisé en <a href=\"https://help.github.com/articles/markdown-basics/\" target=\"_blank\">Markdown de style Github</a>"
    },
    "unknown": {
        "label": {
            "unknown": "inconnu"
        },
        "tip": "<p>Ce noeud est inconnu de votre installation de Node-RED.</p><p><i>Si vous déployez, la configuration du noeud sera préservée mais les flux ne rouleront pas tant que ce type de noeud n'est pas installé.</i></p><p>Voir l'onglet Info pour plus d'informations</p>"
    },
    "mqtt": {
        "label": {
            "broker": "Serveur",
            "example": "ex. localhost",
            "qos": "QoS",
            "clientid": "ID Client",
            "port": "Port",
            "keepalive": "Keep alive time (s)",
            "cleansession": "Utiliser un session vierge",
            "use-tls": "Activer une connection sécurisée (SSL/TLS)",
            "tls-config":"Configuration TLS",
            "verify-server-cert":"Vérifier le certificat du serveur",
            "compatmode": "Utiliser le mode de compatibilité MQTT 3.1"
        },
        "tabs-label": {
            "connection": "Connexion",
            "security": "Sécurité",
            "will": "Message Will",
            "birth": "Message Birth"
        },
        "placeholder": {
            "clientid": "Laissez vide pour générer automatiquement",
            "clientid-nonclean":"Doit être configuré pour les sessions non vierges",
            "will-topic": "Laissez vide pour désactiver le message Will",
            "birth-topic": "Laissez vide pour désactiver le message Birth"
        },
        "state": {
            "connected": "Connecté au broker: __broker__",
            "disconnected": "Déconnecté du broker: __broker__",
            "connect-failed": "Connexion au broker échouée: __broker__"
        },
        "retain": "Retain",
        "true": "vrai",
        "false": "faux",
        "tip": "Tip: Laissez les champs topic, qos ou retain vides si vous voulez les configurer via les propriétés du msg.",
        "errors": {
            "not-defined": "pas de topic défini",
            "missing-config": "configuration du broker absente",
            "invalid-topic": "Topic invalide spécifié",
            "nonclean-missingclientid": "Pas d'ID client configuré, session vierge utilisée"
        }
    },
    "httpin": {
        "label": {
            "method": "Méthode",
            "url": "URL",
            "doc": "Docs",
            "return": "Retour",
            "upload": "Accepter les téléversements de fichiers?",
            "status": "Code de statut",
            "headers": "En-têtes",
            "other": "autre"
        },
        "setby": "- configuré par msg.method -",
        "basicauth": "Utiliser l'authentification de base",
        "use-tls": "Activer une connection sécurisée (SSL/TLS)",
        "tls-config":"Configuration TLS",
        "utf8": "une chaîne de caractères UTF-8",
        "binary": "un tampon binaire",
        "json": "un objet JSON converti",
        "tip": {
            "in": "l'url sera relative à ",
            "res": "Les messages envoyés à ce noeud <b>doivent</b> provenir d'un noeud <i>http input</i>",
            "req": "Tip: Si la conversion JSON échoue, la chaîne de caractères sera retournée telle quelle."
        },
        "httpreq": "requête http",
        "errors": {
            "not-created": "Le noeud http-in ne peut pas être créé quand httpNodeRoot est configuré à false",
            "missing-path": "chemin manquant",
            "no-response": "Pas d'objet réponse",
            "json-error": "Erreur de conversion JSON",
            "no-url": "Pas d'url spécifié",
            "deprecated-call":"Appel de la méthode __method__ n'est plus supporté",
            "invalid-transport":"transport non-http demandé"
        },
        "status": {
            "requesting": "demande"
        }
    },
    "websocket": {
        "label": {
            "type": "Type",
            "path": "Chemin",
            "url": "URL"
        },
        "listenon": "Écouter sur",
        "connectto": "Connecter à",
        "payload": "Envoyer/Recevoir payload",
        "message": "Envoyer/Recevoir message complet",
        "tip": {
            "path1": "By default, <code>payload</code> will contain the data to be sent over, or received from a websocket. The listener can be configured to send or receive the entire message object as a JSON formatted string.",
            "path2": "This path will be relative to ",
            "url1": "URL should use ws:&#47;&#47; or wss:&#47;&#47; scheme and point to an existing websocket listener.",
            "url2": "By default, <code>payload</code> will contain the data to be sent over, or received from a websocket. The client can be configured to send or receive the entire message object as a JSON formatted string."
        },
        "errors": {
            "connect-error": "An error occured on the ws connection: ",
            "send-error": "An error occurred while sending: ",
            "missing-conf": "Missing server configuration"
        }
    },
    "watch": {
        "label": {
            "files": "File(s)",
            "recursive": "Watch sub-directories recursively"
        },
        "placeholder": {
            "files": "Comma-separated list of files and/or directories"
        },
        "tip": "On Windows you must use double back-slashes \\\\ in any directory names."
    },
    "tcpin": {
        "label": {
            "type": "Type",
            "output": "Output",
            "port": "port",
            "host": "at host",
            "payload": "payload(s)",
            "delimited": "delimited by",
            "close-connection": "Close connection after each message is sent?",
            "decode-base64": "Decode Base64 message?",
            "server": "Server",
            "return": "Return",
            "ms": "ms",
            "chars": "chars"
        },
        "type": {
            "listen": "Listen on",
            "connect": "Connect to",
            "reply": "Reply to TCP"
        },
        "output": {
            "stream": "stream of",
            "single": "single",
            "buffer": "Buffer",
            "string": "String",
            "base64": "Base64 String"
        },
        "return": {
            "timeout": "after a fixed timeout of",
            "character": "when character received is",
            "number": "a fixed number of chars",
            "never": "never - keep connection open",
            "immed": "immediately - don't wait for reply"
        },
        "status": {
            "connecting": "connecting to __host__:__port__",
            "connected": "connected to __host__:__port__",
            "listening-port": "listening on port __port__",
            "stopped-listening": "stopped listening on port",
            "connection-from": "connection from __host__:__port__",
            "connection-closed": "connection closed from __host__:__port__",
            "connections": "__count__ connection",
            "connections_plural": "__count__ connections"

        },
        "errors": {
            "connection-lost": "connection lost to __host__:__port__",
            "timeout": "timeout closed socket port __port__",
            "cannot-listen": "unable to listen on port __port__, error: __error__",
            "error": "error: __error__",

            "socket-error": "socket error from __host__:__port__",
            "no-host": "Host and/or port not set",
            "connect-timeout": "connect timeout",
            "connect-fail": "connect failed"
        }
    },
    "udp": {
        "label": {
            "listen": "Listen for",
            "onport": "on Port",
            "using": "using",
            "output": "Output",
            "group": "Group",
            "interface": "Local IP",
            "interfaceprompt": "(optional) local ip address to bind to",
            "send": "Send a",
            "toport": "to port",
            "address": "Address",
            "decode-base64": "Decode Base64 encoded payload?"
        },
        "placeholder": {
            "interface": "(optional) ip address of eth0",
            "address": "destination ip"
        },
        "udpmsgs": "udp messages",
        "mcmsgs": "multicast messages",
        "udpmsg": "udp message",
        "bcmsg": "broadcast message",
        "mcmsg": "multicast message",
        "output": {
            "buffer": "a Buffer",
            "string": "a String",
            "base64": "a Base64 encoded string"
        },
        "bind": {
            "random": "bind to random local port",
            "local": "bind to local port",
            "target": "bind to target port"
        },
        "tip": {
            "in": "Tip: Make sure your firewall will allow the data in.",
            "out": "Tip: leave address and port blank if you want to set using <code>msg.ip</code> and <code>msg.port</code>.",
            "port": "Ports already in use: "
        },
        "status": {
            "listener-at": "udp listener at __host__:__port__",
            "mc-group": "udp multicast group __group__",
            "listener-stopped": "udp listener stopped",
            "output-stopped": "udp output stopped",
            "mc-ready": "udp multicast ready: __outport__ -> __host__:__port__",
            "bc-ready": "udp broadcast ready: __outport__ -> __host__:__port__",
            "ready": "udp ready: __outport__ -> __host__:__port__",
            "ready-nolocal": "udp ready: __host__:__port__"
        },
        "errors": {
            "access-error": "UDP access error, you may need root access for ports below 1024",
            "error": "error: __error__",
            "bad-mcaddress": "Bad Multicast Address",
            "interface": "Must be ip address of the required interface",
            "ip-notset": "udp: ip address not set",
            "port-notset": "udp: port not set",
            "port-invalid": "udp: port number not valid",
            "alreadyused": "udp: port already in use"
        }
    },
    "switch": {
        "label": {
            "property": "Property",
            "rule": "rule"
        },
        "and": "and",
        "checkall": "checking all rules",
        "stopfirst": "stopping after first match",
        "ignorecase": "ignore case",
        "rules": {
            "btwn":"is between",
            "cont":"contains",
            "regex":"matches regex",
            "true":"is true",
            "false":"is false",
            "null":"is null",
            "nnull":"is not null",
            "else":"otherwise"
        },
        "errors": {
            "invalid-expr": "Invalid JSONata expression: __error__"
        }
    },
    "change": {
        "label": {
            "rules": "Rules",
            "rule": "rule",
            "set": "set __property__",
            "change": "change __property__",
            "delete": "delete __property__",
            "move": "move __property__",
            "changeCount": "change: __count__ rules",
            "regex": "Use regular expressions"
        },
        "action": {
            "set": "Set",
            "change": "Change",
            "delete": "Delete",
            "move": "Move",
            "to": "to",
            "search": "Search for",
            "replace": "Replace with"
        },
        "errors": {
            "invalid-from": "Invalid 'from' property: __error__",
            "invalid-json": "Invalid 'to' JSON property",
            "invalid-expr": "Invalid JSONata expression: __error__"
        }
    },
    "range": {
        "label": {
            "action": "Action",
            "inputrange": "Map the input range",
            "resultrange": "to the result range",
            "from": "from",
            "to": "to",
            "roundresult": "Round result to the nearest integer?"
        },
        "placeholder": {
            "min": "e.g. 0",
            "maxin": "e.g. 99",
            "maxout": "e.g. 255"
        },
        "scale": {
            "payload": "Scale msg.payload",
            "limit": "Scale and limit to the target range",
            "wrap": "Scale and wrap within the target range"
        },
        "tip": "Tip: This node ONLY works with numbers.",
        "errors": {
            "notnumber": "Not a number"
        }
    },
    "csv": {
        "label": {
            "columns": "Columns",
            "separator": "Separator",
            "c2o": "CSV to Object options",
            "o2c": "Object to CSV options",
            "input": "Input",
            "firstrow": "first row contains column names",
            "output": "Output",
            "includerow": "include column name row",
            "newline": "Newline"
        },
        "placeholder": {
            "columns": "comma-separated column names"
        },
        "separator": {
            "comma": "comma",
            "tab": "tab",
            "space": "space",
            "semicolon": "semicolon",
            "colon": "colon",
            "hashtag": "hashtag",
            "other": "other..."
        },
        "output": {
            "row": "a message per row",
            "array": "a single message [array]"
        },
        "newline": {
            "linux": "Linux (\\n)",
            "mac": "Mac (\\r)",
            "windows": "Windows (\\r\\n)"
        },
        "errors": {
            "csv_js": "This node only handles CSV strings or js objects.",
            "obj_csv": "No columns template specified for object -> CSV."
        }
    },
    "html": {
        "label": {
            "select": "Selector",
            "output": "Output"
        },
        "output": {
            "html": "the html content of the elements",
            "text": "only the text content of the elements",
            "attr": "an object of any attributes of the elements"
        },
        "format": {
            "single": "as a single message containing an array",
            "multi": "as multiple messages, one for each element"
        }
    },
    "json": {
        "errors": {
            "dropped-object": "Ignored non-object payload",
            "dropped": "Ignored unsupported payload type",
            "dropped-error": "Failed to convert payload"
        },
        "label": {
            "o2j": "Object to JSON options",
            "pretty": "Format JSON string"
        }
    },
    "yaml": {
        "errors": {
            "dropped-object": "Ignored non-object payload",
            "dropped": "Ignored unsupported payload type",
            "dropped-error": "Failed to convert payload"
        }
    },
    "xml": {
        "label": {
            "represent": "Property name for XML tag attributes",
            "prefix": "Property name for tag text content",
            "advanced": "Advanced options",
            "x2o": "XML to Object options"
        },
        "errors": {
            "xml_js": "This node only handles xml strings or js objects."
        }
    },
    "rpi-gpio": {
        "label": {
            "gpiopin": "GPIO",
            "selectpin": "select pin",
            "resistor": "Resistor?",
            "readinitial": "Read initial state of pin on deploy/restart?",
            "type": "Type",
            "initpin": "Initialise pin state?",
            "debounce": "Debounce",
            "freq": "Frequency",
            "button": "Button",
            "pimouse": "Pi Mouse",
            "pikeyboard": "Pi Keyboard",
            "left": "Left",
            "right": "Right",
            "middle": "Middle"
        },
        "resistor": {
            "none": "none",
            "pullup": "pullup",
            "pulldown": "pulldown"
        },
        "digout": "Digital output",
        "pwmout": "PWM output",
        "servo": "Servo output",
        "initpin0": "initial level of pin - low (0)",
        "initpin1": "initial level of pin - high (1)",
        "left": "left",
        "right": "right",
        "middle": "middle",
        "any": "any",
        "pinname": "Pin",
        "alreadyuse": "already in use",
        "alreadyset": "already set as",
        "tip": {
            "pin": "<b>Pins in Use</b>: ",
            "in": "Tip: Only Digital Input is supported - input must be 0 or 1.",
            "dig": "Tip: For digital output - input must be 0 or 1.",
            "pwm": "Tip: For PWM output - input must be between 0 to 100; setting high frequency might occupy more CPU than expected.",
            "ser": "<b>Tip</b>: For Servo output - input must be between 0 to 100. 50 is centre."
        },
        "types": {
            "digout": "digital output",
            "input": "input",
            "pullup": "input with pull up",
            "pulldown": "input with pull down",
            "pwmout": "PWM output",
            "servo": "Servo output"
        },
        "status": {
            "stopped": "stopped",
            "closed": "closed",
            "not-running": "not running"
        },
        "errors": {
            "ignorenode": "Ignoring Raspberry Pi specific node",
            "version": "Version command failed",
            "sawpitype": "Saw Pi Type",
            "libnotfound": "Cannot find Pi RPi.GPIO python library",
            "alreadyset": "GPIO pin __pin__ already set as type: __type__",
            "invalidpin": "Invalid GPIO pin",
            "invalidinput": "Invalid input",
            "needtobeexecutable": "__command__ needs to be executable",
            "mustbeexecutable": "nrgpio must to be executable",
            "commandnotfound": "nrgpio command not found",
            "commandnotexecutable": "nrgpio command not executable",
            "error": "error: __error__",
            "pythoncommandnotfound": "nrpgio python command not running"
        }
    },
    "tail": {
        "label": {
            "filename": "Filename",
            "type": "File type",
            "splitlines": "Split lines on \\n?"
        },
        "action": {
            "text": "Text - returns String",
            "binary": "Binary - returns Buffer"
        },
        "errors": {
            "windowsnotsupport": "Not currently supported on Windows."
        }
    },
    "file": {
        "label": {
            "filename": "Filename",
            "action": "Action",
            "addnewline": "Add newline (\\n) to each payload?",
            "createdir": "Create directory if it doesn't exist?",
            "outputas": "Output",
            "breakchunks": "Break into chunks",
            "breaklines": "Break into lines",
            "filelabel": "file",
            "sendError": "Send message on error (legacy mode)",
            "deletelabel": "delete __file__"
        },
        "action": {
            "append": "append to file",
            "overwrite": "overwrite file",
            "delete": "delete file"
        },
        "output": {
            "utf8": "a single utf8 string",
            "buffer": "a single Buffer object",
            "lines": "a msg per line",
            "stream": "a stream of Buffers"
        },
        "status": {
            "wrotefile": "wrote to file: __file__",
            "deletedfile": "deleted file: __file__",
            "appendedfile": "appended to file: __file__"
        },
        "errors": {
            "nofilename": "No filename specified",
            "invaliddelete": "Warning: Invalid delete. Please use specific delete option in config dialog.",
            "deletefail": "failed to delete file: __error__",
            "writefail": "failed to write to file: __error__",
            "appendfail": "failed to append to file: __error__",
            "createfail": "failed to create file: __error__"
        },
        "tip": "Tip: The filename should be an absolute path, otherwise it will be relative to the working directory of the Node-RED process."
    },
    "split": {
        "intro":"Split <code>msg.payload</code> based on type:",
        "object":"<b>Object</b>",
        "objectSend":"Send a message for each key/value pair",
        "strBuff":"<b>String</b> / <b>Buffer</b>",
        "array":"<b>Array</b>",
        "splitUsing":"Split using",
        "splitLength":"Fixed length of",
        "stream":"Handle as a stream of messages",
        "addname":" Copy key to "
    },
    "join":{
        "mode":{
            "mode":"Mode",
            "auto":"automatic",
            "custom":"manual"
        },
        "combine":"Combine each",
        "create":"to create",
        "type":{
            "string":"a String",
            "array":"an Array",
            "buffer":"a Buffer",
            "object":"a key/value Object",
            "merged":"a merged Object"
        },
        "using":"using the value of",
        "key":"as the key",
        "joinedUsing":"joined using",
        "send":"Send the message:",
        "afterCount":"After a number of message parts",
        "count":"count",
        "subsequent":"and every subsequent message.",
        "afterTimeout":"After a timeout following the first message",
        "seconds":"seconds",
        "complete":"After a message with the <code>msg.complete</code> property set",
        "tip":"This mode assumes this node is either paired with a <i>split</i> node or the received messages will have a properly configured <code>msg.parts</code> property."
    }
}
